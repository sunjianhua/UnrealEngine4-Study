# Unreal Engine4 学习

个别知识点来源于网络，收集的时候没记录出处，侵删或注明出处

项目以目录划分，只上传新增代码，不包含Unreal Engine4创建项目自动生成文件

常用的：UGameplayStatics

## 基本概念

### 命令行参数 (2016-10-12 ~ 2016-10-12)
1. 获得命令行：FCommandLine::Get()
2. 解析命令行：FParse::Value

### 配置文件 (2016-10-13 ~ 2016-10-13)
1. 声明配置文件：FConfigFile
2. 打开配置文件：FConfigFile::Read
3. 获得分组内容：FConfigFile::Find
4. 配置文件分组：FConfigSection
5. 获得分组子项: FConfigSection::Find

### Engine\Source\Runtime\Core\Public\Misc
1. 想到有什么基本功能要写的，就先去这个目录下查一下，是否已经实现

### 定时器
GetWorldTimerManager().SetTimer

### 编译代码
UnrealEngine 4 下载源码，需要在UnrealEngine账户把自己的github账号设置上，不然在github看不到项目

## Additional Non-asset Directories to Package 取资源
FString Contents;
FString Filename = FPaths::GameContentDir() + TEXT("Resource/conf/role/Role.conf");
if (FFileHelper::LoadFileToString(Contents, *Filename))
{
	// do something with Contents
}

## 线程锁定修改单值
FPlatformAtomics::InterlockedExchange(变量指针, 新值);

## 互斥锁
FCriticalSection Lock;
FScopeLock ScopeLock(&Lock);

## 格式化字符串
FString::Printf(TEXT("%s 你好。"), TEXT("朋友"))

## 输出日志
UE_LOG(LogTemp, Log, TEXT("%s 你好。"), TEXT("朋友"));

## 输出信息到屏幕
GEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Yellow, TEXT("朋友 你好。"));

## 输出字符串到屏幕
DrawDebugString
UKismetSystemLibrary::DrawDebugString

## 输出到文件
FOutputDevice::Logf

## 在代码显示/隐藏鼠标的一个方法
FSlateApplication::Get().GetPlatformApplication()->Cursor->Show(false);

## 鼠标检测
1. UWorld::LineTraceSingleByChannel
2. FMath::LinePlaneIntersection
3. APlayerController::GetHitResultAtScreenPosition
4. APlayerController::GetHitResultUnderCursor

## 剪贴板内容拷贝
FPlatformMisc::ClipboardCopy

## 设置AActor旋转
1. USceneComponent* SceneComponent = AActor::GetRootComponent();
2. SceneComponent->SetRelativeRotation(???);
3. SceneComponent->RelativeRotation = ???;
4. AActor::ReregisterAllComponents();

## 获得当前场景所有AActor
方式 1
1. UGameplayStatics::GetAllActorsOfClass
2. for (FActorIterator It(GetWorld()); It; ++It)

方式2
1. TActorRange<AActor> SceneItems(GetWorld());
2. for (AActor* SceneItem : SceneItems)

## 长短文件名 UE4里对短文件名<不包含路径信息>会进行目录遍历，比较耗时，长文件名<包含路径信息>基本是定位查找，比较快
FPackageName::IsShortPackageName

UGameplayStatics::OpenLevel 会根据长短文件名做不同文件查找操作

## Converts a long package name to a file name with the supplied extension
FPackageName::LongPackageNameToFilename

### 路径信息
1. FPaths::GameDir()
2. FPaths::GameSavedDir()
3. FPaths::ProfilingDir()
4. ......

## 判断文件是否存在
1. FPlatformFileManager::Get().GetPlatformFile().FileExists()
2. IFileManager::Get().FileExists

## 判断目录是否存在
1. IFileManager::Get().DirectoryExists

## 创建目录
IFileManager::Get().MakeDirectory

## 获取目录下所有文件或子目录名
IFileManager::Get().FindFiles

## 删除文件
IFileManager::Get().Delete

## 四种加载资源方式【加载Blueprint资源】
### 1. 如果该蓝图有C++类(或者说是从C++类创建的蓝图),直接进行加载
ATemp* spawnActor = GetWorld()->SpawnActor<ATemp>(ATemp::StaticClass());

### 2. 通过ConstructorHelpers加载
~~~
static ConstructorHelpers::FClassFinder<AActor> bpClass(TEXT("/Game/BluePrint/TestObj"));  
if(bpClass.Class != NULL)
{
    GetWorld()->SpawnActor(bpClass.Class);
}
~~~

### 3. 通过FStringAssetReference加载
~~~
FStringAssetReference asset = "Blueprint'/Game/BluePrint/TestObj.TestObj'";
UObject* itemObj = asset.ResolveObject();  
UBlueprint* gen = Cast<UBlueprint>(itemObj);  
if (gen != NULL)   
{
    AActor* spawnActor = GetWorld()->SpawnActor<AActor>(gen->GeneratedClass);
}
~~~

### 4. 通过StaticLoadObject加载
~~~
UObject* loadObj = StaticLoadObject(UBlueprint::StaticClass(), NULL, TEXT("Blueprint'/Game/BluePrint/TestObj.TestObj'"));  
if (loadObj != nullptr)
{
    UBlueprint* ubp = Cast<UBlueprint>(loadObj);
    AActor* spawnActor = GetWorld()->SpawnActor<AActor>(ubp->GeneratedClass);
    UE_LOG(LogClass, Log, TEXT("Success"));
}
~~~

## 加载 StaticMesh 到场景，并设置材质
~~~
UMaterial* MaterialObj = Cast<UMaterial>(StaticLoadObject(UMaterial::StaticClass(), NULL, TEXT("Material'/Game/xxx.xxx'")));
UObject* StaticMeshObj = StaticLoadObject(UStaticMesh::StaticClass(), NULL, TEXT("StaticMesh'/Game/xxx.xxx'"));

AStaticMeshActor* StaticMeshActor = GetWorld()->SpawnActor<AStaticMeshActor>();
StaticMeshActor->GetStaticMeshComponent()->StaticMesh = Cast<UStaticMesh>(StaticMeshObj);
StaticMeshActor->GetStaticMeshComponent()->SetMaterial(0, MaterialObj);
StaticMeshActor->MarkComponentsRenderStateDirty();
~~~

## 删除 Actor
~~~
AActor::Destroy
UObject::ConditionalBeginDestroy
~~~

## 检测 Actor
~~~
check(ThisActor);
check(ThisActor->IsValidLowLevel());
~~~

## 获得 UE4 版本
GEngineVersion

## 定时器回调
~~~
FTimerHandle TimerHandle;
FTimerDelegate TimerDelegate;
TimerDelegate.BindLambda([this, HitMeshComponent] {});

GetWorld()->GetTimerManager().SetTimer(TimerHandle, TimerDelegate, 0.5, false);
~~~

## 显示或关闭组件边框线
UPrimitiveComponent::SetRenderCustomDepth

## 时间线
蓝图组件：TimeLine

## 转换屏幕位置到3D空间
1. FSceneView::DeprojectScreenToWorld
2. UGameplayStatics::DeprojectScreenToWorld

## 获得字符串宽度
~~~
const TSharedRef< FSlateFontMeasure > FontMeasure = FSlateApplication::Get().GetRenderer()->GetFontMeasureService();
FVector2D Size = FontMeasure->Measure(*String, GEngine->GetMediumFont()->GetLegacySlateFontInfo());
~~~

## 获得窗口的宽高
~~~
FSceneViewProjectionData::GetConstrainedViewRect
可以用ULocalPlayer::GetProjectionData获得FSceneViewProjectionData
可以用APlayerController::GetLocalPlayer获得ULocalPlayer
~~~

## 输出内存信息到磁盘
控制台下Memreport【UEngine::HandleMemCommand】

## 获得内存信息
FPlatformMemory::GetStats

## 捕获堆栈信息
FWindowsPlatformStackWalk::CaptureStackBackTrace

## 点关闭按钮后做特别处理
~~~
// TSharedPtr<SWindow> ActiveTopLevelWindow = GEngine->GameViewport->GetWindow();
TSharedPtr<SWindow> ActiveTopLevelWindow = FSlateApplication::Get().GetActiveTopLevelWindow();
FRequestDestroyWindowOverride RequestDestroyWindowOverride;
RequestDestroyWindowOverride.BindLambda([](const TSharedRef<SWindow>& WindowBeingClosed)
{
	UE_LOG(LogTemp, Log, TEXT("%s 執行了關閉"));
});
ActiveTopLevelWindow->SetRequestDestroyWindowOverride(RequestDestroyWindowOverride);
~~~

## 怎么在一个死循环里处理游戏循环
~~~
【FAsyncTask】
【FTaskGraphInterface::Get().WaitUntilTaskCompletes(CompleteHandle);】
【
do
	{
		CheckRenderingThreadHealth();
		if (bEmptyGameThreadTasks)
		{
			// process gamethread tasks if there are any
			FTaskGraphInterface::Get().ProcessThreadUntilIdle(ENamedThreads::GameThread);
		}
		bDone = Event->Wait(WaitTime);
	}
while (!bDone);
】
~~~

## 获得当前帧鼠标移动距离
APlayerController::GetInputMouseDelta

## 旋转增量
AActor::AddActorLocalRotation

## UMaterialInstanceDynamic 设置纹理
~~~
UMaterialInstanceDynamic* MaterialInstanceDynamic = UKismetMaterialLibrary::CreateDynamicMaterialInstance();
UTexture2D* LoadedTexture = LoadObject<UTexture2D>();
if (LoadedTexture)
	MaterialInstanceDynamic->SetTextureParameterValue();
~~~

## 获得纹理尺寸
~~~
UMaterialInstanceDynamic* MaterialInstanceDynamic = ？？？？？？;
UTexture* Texture = NULL;
if (MaterialInstanceDynamic->GetTextureParameterValue(TEXT("tBaseTexture"), Texture))
{
	if (Texture->Resource)
	{
		SizeX = Texture->Resource->GetSizeX();
		SizeY = Texture->Resource->GetSizeY();
	}
}
~~~

## 绘制自定义网格
继承这个类：UProceduralMeshComponent

## 检查UActorComponent的标签
UActorComponent::ComponentHasTag

## 判断组件材质的是否为半透明的混合模式
~~~
UMaterialInterface* MaterialInterface = Component->GetMaterial(???);
IsTranslucentBlendMode(MaterialInterface->GetBlendMode())
~~~

## 克隆一个AActor
~~~
AActor* pTemplate;
FActorSpawnParameters* params = new FActorSpawnParameters();
params->Template = pTemplate;
AActor* newActor = GetWorld()->SpawnActor(pTemplate->GetClass(), 位置, 旋转, *params);
GetWorld()->AddNetworkActor(newActor);
~~~

## 克隆一个UActorComponent组件
~~~
AActor* Actor;
UActorComponent* ActorComponent = Actor->CreateComponentFromTemplate(要克隆的组件);

ActorComponent->RegisterComponent();
ActorComponent->AddInstanceComponent(newComponent);
~~~

## 创建边框盒
~~~
这个真是方便，只要给顶点数据就可以了
FBox Box;
Box += FVector;
~~~

## Dynamic UObject Allocation
.H
```
UPROPERTY()
UMyObjectClass* MyGCProtectedObj;
```
.CPP
```
MyGCProtectedObj = NewObject<UMyObjectClass>(this);
```

> **用 UPROPERTY() 防止垃圾收集，如果不用 UPROPERTY()，防止垃圾收集，可以用：YourObjectInstance->AddToRoot();**

## 动态创建UObject（所有继承于UObject）
1. CreateDefaultSubobject 只能在构造函数里使用
2. NewObject 可以在任何地方使用【也可以用ConstructObject，4.8版本后这个就不建议用了】
3. 下面这个写法不用通过TSubclassOf<UObject>到蓝图里指定UClass instance
	> NewObject<UObject>(GetTransientPackage(), UObject::StaticClass());

## 动态创建UActorComponent
~~~
UActorComponent* NewComponent = NewObject<UActorComponent>(this, UActorComponent::StaticClass());
NewComponent->RegisterComponent();
NewComponent->AttachTo(GetRootComponent());
NewComponent->SetWorldLocationAndRotation(NewLocation, NewRotation);
~~~

## IsPendingKill() vs IsValidLowLevel()
~~~
https://answers.unrealengine.com/questions/211586/ispendingkill-vs-isvalidlowlevel.html
IsPendingKill：检测对象是否rendering current frame后销毁
IsValidLowLevel：检测对象是否有效
~~~

## UStaticMesh vs UInstancedStaticMeshComponent
~~~
https://answers.unrealengine.com/questions/10984/question-difference-between-instancedstaticmesh-an.html

InstancedStaticMeshComponents are used to draw multiple instances of the same StaticMesh in one draw call. You basically add one of those (per StaticMesh asset you need to draw) and then add instances to it along with the transform (position, rotation, scale) for each instance. So, if you have one StaticMesh that needs to be placed many times, this could be an optimization. If you just have lots of different StaticMeshes you are adding to your Blueprint, I don't think you would see any improvement.
~~~

## GetPlayerCameraManager
UGameplayStatics::GetPlayerCameraManager

## SetViewTargetWithBlend / SetViewTarget
APlayerController::SetViewTarget：第一个参数class AActor* 类型，没搞明白处理视口的流程？？？？？？

## 判断浮点数近似相等可以用
KINDA_SMALL_NUMBER

## Json操作
~~~
TJsonReaderFactory
FJsonSerializer
FJsonObject
FJsonObjectConverter::JsonObjectStringToUStruct
~~~

## 绘制常用图形函数
~~~
SceneManagement.h

绘制蚂蚁线：DrawDashedLine
~~~

## 绑定一个ACtor到另一个ACtor
AActor::AttachRootComponentToActor

## 获得ACtor下绑定的其它ACtor
AActor::GetAttachedActors

## 字符转换函数
~~~
StringConv.h

TCHAR_TO_ANSI ANSI_TO_TCHAR TCHAR_TO_UTF8 UTF8_TO_TCHAR
~~~

## C 字符串操作
~~~
TCString

封装了一些 C 字符操作的 Api
~~~

## 干净的浮点转 FString
~~~
FString::SanitizeFloat

For example - 1.234 will be "1.234" rather than "1.234000"
~~~

## 快速关闭
~~~
FPlatformMisc::RequestExit(true);
~~~

## 正常关闭
~~~
APlayerController* playerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);
if (playerController)
{
    //EQuitPreference::Quit 完整退出
    //EQuitPreference::Background 移动到后台退出
    UKismetSystemLibrary::QuitGame(GetWorld(), playerController, EQuitPreference::Quit);
}
~~~

## UObject 实现 Tick
集成自 UObject 的类，实现Tick，可以再继承 FTickableGameObject

## !HasAnyFlags(RF_ClassDefaultObject)
？？？看文档没看明白，这个可以在编辑器下进行当前类的状态监测？？？
```
bool FTickableGameObject::IsTickable() const
{
	return !HasAnyFlags(RF_ClassDefaultObject);
}
```

## 获得PlayerController
```
UGameplayStatics::GetPlayerController
```

## 检测按键是否按下
```
APlayerController::IsInputKeyDown
```

## 屏幕坐标到世界坐标
```
FSceneView::DeprojectScreenToWorld
```

## 物体绕某个点旋转（基于四元数）
```
URotatingMovementComponent::TickComponent
```

## 获得GameInstance
```
UGameplayStatics::GetGameInstance
AActor::GetGameInstance
```

## 获得FSceneViewport
```
FSceneViewport* Viewport = AActor::GetGameInstance()->UGameInstance::GetGameViewportClient()->UGameViewportClient::GetGameViewport();
```

## 获得窗口长宽比
```
FViewport::GetDesiredAspectRatio
```

## 居中显示物品
```
FEditorViewportClient::FocusViewportOnBox
```

## 获得物品的边框
```
virtual FBox AActor::GetComponentsBoundingBox
```

## 门的开关
```
TimeLine + UKismetMathLibrary::TEase
```

## 代码到蓝图

## ModuleRules (2016-10-14 ~ )

~~~
1. 直接绑定一个按键：BindKey
~~~
~~~
2. GetWorldTimerManager().SetTimer
~~~
~~~
3. Using Timers in Blueprints
https://docs.unrealengine.com/latest/INT/Gameplay/HowTo/UseTimers/Blueprints/index.html
~~~
~~~
4. 让镜头围绕人物旋转
{
ACharacter::bUseControllerRotationYaw = false;
USpringArmComponent::bUsePawnControlRotation
}
~~~
~~~
5. 镜头跟随人物旋转
{
ACharacter::bUseControllerRotationYaw = true;
}
~~~
~~~
6. 控制跳起后，如果转身，是否还能在空中移动，=0跳转后只能在空中转身，不能移动
UCharacterMovementComponent::AirControl
~~~
~~~
7. FOnTimelineFloat，BindUFunction的回调函数，声明时要加UFUNCTION()关键字，不然不会触发回调
~~~
~~~
8. 获得当前镜头跟随的生物
class APlayerCameraManager* APlayerController::PlayerCameraManager;
APawn* APlayerCameraManager::GetViewTargetPawn()
~~~
~~~
9. UFUNCTION(BlueprintImplementableEvent) 传递FString参数
void BlueprintImplementableEventFunction(const FString& String);
~~~
~~~
10. GEngine->GetFirstLocalPlayerController
~~~
~~~
11. RPC (client to server) on owning actor not working

void ABasePlayerController::ServerSpawnSoldiers_Implementation(const TArray<ESoldierTypes>& aSoldierArray, FVector aPosition, APlayerController* aOwner)
      {
          UE_LOG(LogTemp, Warning, TEXT("received soldier spawn"));
          FActorSpawnParameters tParams;
          tParams.Owner = aOwner;
          ABaseSoldier* tSoldier = (ABaseSoldier*)GetWorld()->SpawnActor(mMeleeSoldier, &aPosition, &FRotator::ZeroRotator, tParams);
          tSoldier->GetController()->SetOwner(aOwner);
      }
~~~
~~~
12. 三种动作映射方式
这两个是需要在编辑配置按键映射的
{
	1. BindAxis：这个是有数值传入的，比如前后左右移动，传入的移动增值	
	2. BindAction：这个判断按键响应状态，比如是按下、抬起、组合键。
}
这个不需要在编辑器配置按键映射
{
	3. BindKey，这个直接传入按键值 EKeys::R
} 
~~~
~~~
13. 切换观察者和玩家
void APlayerController::ChangeState(FName NewState)
~~~
~~~
14. FTimeline SwitchCameraTimeline;
~~~
~~~
15.  枚举转字符串
https://wiki.unrealengine.com/Enums_For_Both_C%2B%2B_and_BP

FString GetVictoryEnumAsString(EVictoryEnum::Type EnumValue)
{
  const UEnum* EnumPtr = FindObject<UEnum>(ANY_PACKAGE, TEXT("EVictoryEnum"), true);
  if(!EnumPtr) return FString("Invalid");
 
  return EnumPtr->GetNameByValue((int64)EnumValue); // for EnumValue == VE_Dance returns "VE_Dance"
}
~~~
~~~
16. 在服务器获得所有玩家
for (FConstPlayerControllerIterator Iterator = GetWorld()->GetPlayerControllerIterator(); Iterator; ++Iterator)
~~~
~~~
17. 解决按键冲突
FInputBinding::bConsumeInput = false
~~~
~~~
18. for (auto PawnActor : TActorRange<APawn>(GetWorld()))
~~~
~~~
19. 在c++创建的组件【CreateDefaultSubobject】，虽然在编辑器里可以看到，但是要调用【SetupAttachment】
~~~
~~~
20. 人物换装的一个实现，是多个USkeletalMeshComponent的组合，子USkeletalMeshComponent要调用SetMasterPoseComponent
~~~
~~~
21. 用NewObject创建出来的Component，要调用RegisterComponent，CreateDefaultSubobject 创建出来的Component，不需要再调用RegisterComponent
~~~
~~~
22. 设置父类的成员对象类型
1. 子类里 GENERATED_UCLASS_BODY()
2. 子类构造函数 : Super(ObjectInitializer.SetDefaultSubobjectClass<UPlatformerPlayerMovementComp>(ACharacter::CharacterMovementComponentName))
~~~
~~~
23. 偏移子组件的位置，一定要把偏移量根据父组件的旋转做一次旋转
FQuatRotationMatrix(ParentRotator.Quaternion()).TransformVector(OffsetVector);
~~~
~~~
24. 在 客户端处理模拟角色移动后 需要增加的业务逻辑
1. AActor::PostNetReceiveLocationAndRotation
这个是 FRepMovement AActor::ReplicatedMovement 被服务器改变后，客户端的同步通知回调，配合virtual void SmoothCorrection(const FVector& OldLocation, const FQuat& OldRotation, const FVector& NewLocation, const FQuat& NewRotation) PURE_VIRTUAL(INetworkPredictionInterface::SmoothCorrection,);函数，圆滑移动？
~~~
~~~
2. void UCharacterMovementComponent::SmoothClientPosition
~~~
~~~
1.	UFUNCTION(BlueprintImplementableEvent)，FString参数只能传递引用
~~~
~~~
2.	FStreamableManager::RequestAsyncLoad，异步加载
~~~
~~~
3.  	// 转化到当前actor的坐标系下
	Vector = GetActorTransform().Inverse().TransformVector(Vector);
~~~
~~~
4.	/** Flags all component's render state as dirty	 */
	void MarkComponentsRenderStateDirty();
~~~
~~~
	5. FScopedPreventAttachedComponentMove类可以限制某个组件暂时不跟随父类组件移动。
~~~
~~~
6. 	FMath::FInterpTo(CurrentSwimSpeed, MovementSpeed.SwimSpeed, DeltaTime, 1);
~~~
~~~
7.	/** 重载这个，可以判断是否进入一个别的物理体 */
	APhysicsVolume::IsOverlapInVolume
~~~
~~~
8.	/** 重点 */
	移动圆滑处理：服务器一步到位，客户端做插值
~~~
~~~
9.	Cannot create Blueprint class based
	UCLASS(Blueprintable) 
~~~
~~~
10.	UAnimInstance::GetStateMachineIndexAndDescription 得到状态机
	UAnimInstance::GetInstanceStateWeight 获得状态机权重，检测一个状态是否切换结束
~~~
~~~
	/** 检测和那些组件产生了碰撞 */
11.	UPrimitiveComponent::GetOverlapInfos()
	获得和UPrimitiveComponent产生Overlap的所有FHitResult
~~~
~~~
12.	UPrimitiveComponent::ComponentOverlapMulti
	同时检测多个碰撞体的碰撞
~~~
~~~
13. 	APawn::FaceRotation
	设置生物的旋转
~~~
~~~
14.	APlayerController::InputYawScale/InputPitchScale/InputRollScale
	设置视口的旋转速度
~~~
~~~
	/** 关键函数 */
15.	APlayerController::UpdateRotation
	串联起了相机管理、玩家控制、生物的旋转操作
~~~
~~~
16.	瞄准时的中间正常，四周虚化
	APlayerCameraManager::UpdateViewTarget(FTViewTarget& OutVT, float DeltaTime)
	FTViewTarget.POV.PostProcessSettings，通过这里传递后处理相关的材质
~~~
~~~
17.	换观察玩家视角
	APlayerController::SetViewTarget
	ServerViewSelf、ServerViewNextPlayer：这个会服务器和客户端都执行SetViewTarget
~~~
~~~
18.	观察和正常状态的切换
	APlayerController::ChangeState
~~~
~~~
19.	当前相机是第一人陈/第三人称/自由模式
	APlayerCameraManager::CameraStyle
~~~
~~~
20.	如果GetMovementComponent()没有设置单独的PhysicsVolume()，那么这个设置是全局的TerminalVelocity一定慎重【GetMovementComponent()->GetPhysicsVolume()->TerminalVelocity】
~~~
~~~
1.	Replicated 的属性，只有值改变了才会同步到客户端【有强制同步的么？】
~~~
~~~
2.	获得和PrimitiveComponent产生Overlap的所有Info，这个是每帧都有处理的
	UPrimitiveComponent::GetOverlapInfos()
~~~
~~~
3.	获得当前生物踩的PrimitiveComponent，这个是适时更新的
	UCharacterMovementComponent::CurrentFloor
~~~
~~~
4.	获得角色和当前地面夹角
	const float FloorDotVelocity = FVector::DotProduct(Movement->CurrentFloor.HitResult.ImpactNormal, Movement->Velocity.GetSafeNormal());
	FMath::RadiansToDegrees(FMath::Acos(FloorDotVelocity))
~~~
~~~
5.	获得能走斜坡角度
	const UPrimitiveComponent* HitComponent = Hit.Component.Get();
	if (HitComponent)
	{
		const FWalkableSlopeOverride& SlopeOverride = HitComponent->GetWalkableSlopeOverride();
		TestWalkableZ = SlopeOverride.ModifyWalkableFloorZ(TestWalkableZ);
	}

	UCharacterMovementComponent::CurrentFloor
~~~
~~~
6.	/** 这个有演示怎么撤销移动 */
	bool UCharacterMovementComponent::StepUp(const FVector& GravDir, const FVector& Delta, const FHitResult &InHit, FStepDownResult* OutStepDownResult)
~~~
~~~
7.	/** 这个有演示怎么提前模拟计算移动 */
	UProjectileMovementComponent::TickComponent
~~~
~~~
8.	/** 移动撤销？ */
	RevertMove
~~~
~~~
9.	/** 旋转? */
	ComputeOrientToMovementRotation
~~~
~~~
10.	/*这个会阻止附加的某个组件不移动*/
	FScopedPreventAttachedComponentMove
~~~
~~~
11.	/* 获得预测数据 */
	GetPredictionData_Client
~~~
~~~
12.	判断是否能移动
	UCharacterMovementComponent::IsWalkable
~~~
~~~
13.	根据方向构造一个面
	UMovementComponent::ConstrainDirectionToPlane
~~~
~~~
1.	获得对象缺省的字段信息
	GetDefault<AObject>(Object->GetClass());
	Object->GetClass()->GetDefaultObject()
~~~
~~~
2.	获得角色立足的物体信息
	ACharacter::BasedMovement
	UCharacterMovementComponent::GetMovementBase()
	FFindFloorResult UCharacterMovementComponent::CurrentFloor
~~~
~~~
3.	撤销当前移动
	UCharacterMovementComponent::RevertMove
~~~
~~~
4.	SCOPE_CYCLE_COUNTER
	有
~~~
~~~
5.	USceneComponent::SetRelativeLocationAndRotation
	这个有计算目标移动和现有位置的增量
~~~
~~~
6.	AController::SetControlRotation
	这个有旋转变化会执行
~~~
~~~
7.	AInstancedFoliageActor::FoliageTrace
	演示怎么碰撞体扫描
~~~
~~~
MarkRenderStateDirty
~~~
~~~
{
	速率根据加速度计算，人物运动分为两个部分：朝向，前进方向

	Control 的旋转根据 输入设置计算
	加速度，客户端传递给服务器，根据 输入值 和 朝向【可以是角色、Control或其它任何旋转】 计算

	1. 朝向：根据 Control 的旋转设置，朝向可以设置是否跟随 Control，具体可以看 	APawn::FaceRotation、APlayerController::UpdateRotation

	2. 前进方向【速率】：根据 加速度 计算

	按Alt在水里游泳的问题是：
	旋转朝向正常，角色不用 Control 的旋转
	加速度不正常，用的 Control 的旋转

	按Alt在跑动的问题是：
	APawn::bUseControllerRotationYaw 不同步，导致 APlayerController::UpdateRotation->APawn::FaceRotation 里处理角色朝向，客户端和服务器不同
}
~~~
~~~
鬼影是由于taa造成的，实现方法是修改控制台里taa和前后帧的影响权重，是得鬼影现象弱化，但是这样做会让画面变的锐利感很强。
~~~
~~~
1.	服务器调用客户端设置视口目标
	APlayerController::ClientSetViewTarget
~~~
~~~
2.	客户端设置视口目标
	APlayerController::SetViewTarget
~~~
~~~
1.	动态调整眼高【比如蹲下和站立】，可以继承下面函数，做 BaseEyeHeight 插值
	RecalculateBaseEyeHeight
~~~
~~~
2.	USceneComponent::GetPhysicsVolume() 这个可以判断当前所处的PhysicsVolume，比如是否在水体
~~~
~~~
2. 网络状态更新，在一帧内，可能不同逻辑会对一个地方重复处理，在不能确保所有执行顺序逻辑的情况下，为了确保一个状态一定会更新，可以用settime，延迟到下一帧执行
~~~
~~~
碰撞通道
1. LineTraceSingleByChannel 只会对 Trace Channel 为 Block 的 有回应，对OverLay的L略过
~~~
~~~
功能点
1.	增加命令行命令
	DECLARE_CYCLE_STAT

1.	回复值到初始值
	TGuardValue
	TScopeCounter

1.	这个演示怎么处理掉输入，以及怎么向服务器告诉移动信息
	UCharacterMovementComponent::TickComponent

2.	这个执行一次后就会让移动收入清零
	Internal_ConsumeMovementInputVector
	GetPendingMovementInputVector
	UPawnMovementComponent::ConsumeInputVector

	UPawnMovementComponent::GetPendingInputVector()
3.	输入的产生、消费、处理
	AddMovementInput(Direction, ScaleValue);
	ConsumeInputVector();
	UCharacterMovementComponent::TickComponent
4.	PhysWalking 前需要执行的两个函数
	Acceleration = ScaleInputAcceleration(ConstrainInputAcceleration(InputVector));
	AnalogInputModifier = ComputeAnalogInputModifier();
~~~
~~~
1. 穿透调整
UMovementComponent::GetPenetrationAdjustment
2.	演示怎么根据穿插回调
void UCableComponent::PerformCableCollision()
3. 穿插调整
UMovementComponent::GetPenetrationAdjustment
~~~
~~~
DrawDebugSweptSphere
DrawDebugCapsuleTraceSingle
~~~
~~~
有移动撤销
UCharacterMovementComponent::StepUp
~~~
~~~
{
	移动遇到碰撞体处理
	UCharacterMovementComponent::HandleImpact

	调用

	移动遇到碰撞体处理
	ACharacter::MoveBlockedBy
}
~~~
~~~
/** 移动撤销？ */
RevertMove
~~~
~~~
/** 这个有演示怎么撤销移动 */
StepUp
~~~
~~~
/** 移动的可视化调试信息 */
VisualizeMovement
~~~
~~~
/* 这个会阻止附加的某个组件不移动 */
FScopedPreventAttachedComponentMove
~~~
~~~
float GetInstanceStateWeight(int32 MachineIndex, int32 StateIndex);
GetStateMachineIndexAndDescription
~~~
~~~
ControlRotation与ActorRotation
APawn::GetActorEyesViewPoint
APlayerController::UpdateRotation
APawn::FaceRotation
~~~
~~~
DrawDebugDirectionalArrow(GetWorld(), DesiredLoc, DesiredLoc + ToOrigin * 0.5f, 7.5f, bClampedDist ? FColor::Red : FColor::Green);
~~~
~~~

【地形学习】

材质编辑器：主要是把颜色作为基本运算单元，做各种计算【+-*/%】，红色：#FF0000 绿色：#00FF00，那么这两个相加就是：#FFFF00。图片由各种颜色组成，都可以对应到10101010，除了颜色本身外，颜色一般标识为R，G，B，额外参数是Alpha值，控制颜色混合时的权重

地形编辑器：主要是把顶点作为基本运算单元，做各种计算【+-*/%】，比如一个山高1000，另一个山高1000，那么这两个山高相加就是2000，顶点一般在三维空间表示为X，Y，Z，额外参数是W ？？？

颜色和顶点在计算机里都是浮点数的集合，所以可以很方便进行各种运算，和各种插值操作，比如一个山高1000，另一个山高2000，两个山之间做线性插值，那么在两个山之间的中点高为1500，比如一个颜色是红色，另一个绿色，那么在

根据以上，所以顶点和颜色可以互相转换，顶点可以转换为颜色，颜色可以转换为顶点，比如

Generator
【
	Radial Grad: 产生一个圆锥山体
	Voronoi: 坑坑洼洼的地形
	Constant：和别的山做运算，让别的山保持山形状的情况下，调节山高
	Gradient：改变山体的朝向，让山体变的圆滑和降低高度，可以做到地形的切片效果
	Color Generator：根据山体高度生成颜色
	Layout Generator：自己绘制山体的走势
	Perlin Noise：数字化造山
	Advanced Perlin：数字化造山，增强版
】

Combiner
【
	Combiner：组合不同的地形，有几种组合方法，合理的利用，可以中和尖的，拉高低的，降低低的
】

Filter
【
	Clamp：改变山的高度相关，不光是整体山高，比如可以让山顶扩大，山变的陡峭，增加山的垂直高度，降低地平面
	Simple Transofrms：改变山的峡谷、高原、山体等
	Terrace：梯田？？？
	Curves：曲线，这个好玩，无意义？？？
	Simple Displacement：旋转地形，让地形偏移
	Ramp：把地形转换为波纹
	Height Splitter：把地形转换为环形
	Add Noise：增加地形的坑坑洼洼
	Flipper：左右或上下翻转地形
	Equalizer：降低山的尖度？？？
	Blue：让山的尖度变圆润？？？
	Expander：使山体高低不平的逐渐填平
	Inverter：让高的变低，低的变高
	Bias/Gain: 让高的更高，低的更低
】

https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/HowTo/CreatingLayeredMaterials/index.html
WorldAlignedBlend
WorldAlignedNormal
WorldAlignedTexture
SlopeMask
MatlayerBlend_Simple
MatlayerBlend_Standard
ComponentMask
MakeMaterialAttributes
MatLayerBlend_StandardWithDisplacement
【
WorldAlignedTexture：全局一致纹理【函数用于在全局空间中的对象表面上平铺纹理，此平铺与该对象的大小或旋转无关。此函数允许您指定投射纹理的方向，并按全局单位（而非纹理大小的百分比）进行比例调整】
因为此函数在全局空间内平铺纹理，所以需要注意，任何以此方式处理纹理的动画对象都会发生纹理“漂浮”，即纹理保持原位置不动，而对象在其下方滑动
】
【
HeightLerp：高度插值【函数允许您根据高度贴图和过渡阶段值，在 2 个纹理之间执行线性插值。这允许您沿着发生插值的高度贴图来调整值】
】
PixelDepth：像素深度【表达式输出当前所渲染像素的深度，即从摄像机开始计算的距离】
SceneDepth：场景深度【类似于 PixelDepth（像素深度），PixelDepth（像素深度）只能在当前所绘制像素处进行深度取样，而 SceneDepth（场景深度）可以在 任何位置 进行深度取样】
Divide
LinearInterpolate
FuzzyShading1
Clamp
Landscape Layer Sample
Bump Offset: 设置凹凸贴图偏移【https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/HowTo/BumpOffset/index.html】
Panner：产生 UV 坐标动画【https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/HowTo/AnimatingUVCoords/index.html】
后期处理体积【Post Process Volume】
Detail Texturing：细节纹理化【https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/HowTo/DetailTexturing/index.html】

https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/ExpressionReference/Vector/index.html#cameravectorws
https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/HowTo/Making_Functions/index.html
{
	ActorPositionWS：Actor 全局空间位置【输出 Vector3 (RGB) 数据，该数据代表使用此材质的对象在全局空间中的位置】
	CameraWorldPosition：摄像机全局空间位置【表达式输出三通道矢量值，该值代表摄像机在全局空间中的位置】
	CameraVectorWS：摄像机全局空间矢量【表达式输出一个三通道矢量值，该值代表摄像机相对于表面的方向，即从像素到摄像机的方向】
}

https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/HowTo/Fresnel/index.html

坐标表达式
https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/ExpressionReference/Coordinates/index.html

LandscapeLayerWeight：地形图层权重节点【表现允许材质网络进行混合。混合的基础是从材质应用的地形上所获取的相关图层权重】
LandscapeLayerSample：这个会产生绘制层
LandscapeLayerBlend：【LB Height Blend，这个选项能产生沙子层里的沙子落在岩石层里的岩石缝隙里？？？？？？】
~~~
