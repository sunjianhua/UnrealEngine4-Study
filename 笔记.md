# Unreal Engine4 学习

个别知识点来源于网络，收集的时候没记录出处，侵删或注明出处

项目以目录划分，只上传新增代码，不包含Unreal Engine4创建项目自动生成文件

常用的：UGameplayStatics

## 基本概念

### 命令行参数 (2016-10-12 ~ 2016-10-12)
1. 获得命令行：FCommandLine::Get()
2. 解析命令行：FParse::Value

### 配置文件 (2016-10-13 ~ 2016-10-13)
1. 声明配置文件：FConfigFile
2. 打开配置文件：FConfigFile::Read
3. 获得分组内容：FConfigFile::Find
4. 配置文件分组：FConfigSection
5. 获得分组子项: FConfigSection::Find

### Engine\Source\Runtime\Core\Public\Misc
1. 想到有什么基本功能要写的，就先去这个目录下查一下，是否已经实现

### 定时器
GetWorldTimerManager().SetTimer

### 编译代码
UnrealEngine 4 下载源码，需要在UnrealEngine账户把自己的github账号设置上，不然在github看不到项目

## Additional Non-asset Directories to Package 取资源
FString Contents;
FString Filename = FPaths::GameContentDir() + TEXT("Resource/conf/role/Role.conf");
if (FFileHelper::LoadFileToString(Contents, *Filename))
{
	// do something with Contents
}

## 线程锁定修改单值
FPlatformAtomics::InterlockedExchange(变量指针, 新值);

## 互斥锁
FCriticalSection Lock;
FScopeLock ScopeLock(&Lock);

## 格式化字符串
FString::Printf(TEXT("%s 你好。"), TEXT("朋友"))

## 输出日志
UE_LOG(LogTemp, Log, TEXT("%s 你好。"), TEXT("朋友"));

## 输出信息到屏幕
GEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Yellow, TEXT("朋友 你好。"));

## 输出字符串到屏幕
DrawDebugString
UKismetSystemLibrary::DrawDebugString

## 输出到文件
FOutputDevice::Logf

## 在代码显示/隐藏鼠标的一个方法
FSlateApplication::Get().GetPlatformApplication()->Cursor->Show(false);

## 鼠标检测
1. UWorld::LineTraceSingleByChannel
2. FMath::LinePlaneIntersection
3. APlayerController::GetHitResultAtScreenPosition
4. APlayerController::GetHitResultUnderCursor

## 剪贴板内容拷贝
FPlatformMisc::ClipboardCopy

## 设置AActor旋转
1. USceneComponent* SceneComponent = AActor::GetRootComponent();
2. SceneComponent->SetRelativeRotation(???);
3. SceneComponent->RelativeRotation = ???;
4. AActor::ReregisterAllComponents();

## 获得当前场景所有AActor
方式 1
1. UGameplayStatics::GetAllActorsOfClass
2. for (FActorIterator It(GetWorld()); It; ++It)

方式2
1. TActorRange<AActor> SceneItems(GetWorld());
2. for (AActor* SceneItem : SceneItems)

## 长短文件名 UE4里对短文件名<不包含路径信息>会进行目录遍历，比较耗时，长文件名<包含路径信息>基本是定位查找，比较快
FPackageName::IsShortPackageName

UGameplayStatics::OpenLevel 会根据长短文件名做不同文件查找操作

## Converts a long package name to a file name with the supplied extension
FPackageName::LongPackageNameToFilename

### 路径信息
1. FPaths::GameDir()
2. FPaths::GameSavedDir()
3. FPaths::ProfilingDir()
4. ......

## 判断文件是否存在
1. FPlatformFileManager::Get().GetPlatformFile().FileExists()
2. IFileManager::Get().FileExists

## 判断目录是否存在
1. IFileManager::Get().DirectoryExists

## 创建目录
IFileManager::Get().MakeDirectory

## 获取目录下所有文件或子目录名
IFileManager::Get().FindFiles

## 删除文件
IFileManager::Get().Delete

## 四种加载资源方式【加载Blueprint资源】
### 1. 如果该蓝图有C++类(或者说是从C++类创建的蓝图),直接进行加载
ATemp* spawnActor = GetWorld()->SpawnActor<ATemp>(ATemp::StaticClass());

### 2. 通过ConstructorHelpers加载
~~~
static ConstructorHelpers::FClassFinder<AActor> bpClass(TEXT("/Game/BluePrint/TestObj"));  
if(bpClass.Class != NULL)
{
    GetWorld()->SpawnActor(bpClass.Class);
}
~~~

### 3. 通过FStringAssetReference加载
~~~
FStringAssetReference asset = "Blueprint'/Game/BluePrint/TestObj.TestObj'";
UObject* itemObj = asset.ResolveObject();  
UBlueprint* gen = Cast<UBlueprint>(itemObj);  
if (gen != NULL)   
{
    AActor* spawnActor = GetWorld()->SpawnActor<AActor>(gen->GeneratedClass);
}
~~~

### 4. 通过StaticLoadObject加载
~~~
UObject* loadObj = StaticLoadObject(UBlueprint::StaticClass(), NULL, TEXT("Blueprint'/Game/BluePrint/TestObj.TestObj'"));  
if (loadObj != nullptr)
{
    UBlueprint* ubp = Cast<UBlueprint>(loadObj);
    AActor* spawnActor = GetWorld()->SpawnActor<AActor>(ubp->GeneratedClass);
    UE_LOG(LogClass, Log, TEXT("Success"));
}
~~~

## 加载 StaticMesh 到场景，并设置材质
~~~
UMaterial* MaterialObj = Cast<UMaterial>(StaticLoadObject(UMaterial::StaticClass(), NULL, TEXT("Material'/Game/xxx.xxx'")));
UObject* StaticMeshObj = StaticLoadObject(UStaticMesh::StaticClass(), NULL, TEXT("StaticMesh'/Game/xxx.xxx'"));

AStaticMeshActor* StaticMeshActor = GetWorld()->SpawnActor<AStaticMeshActor>();
StaticMeshActor->GetStaticMeshComponent()->StaticMesh = Cast<UStaticMesh>(StaticMeshObj);
StaticMeshActor->GetStaticMeshComponent()->SetMaterial(0, MaterialObj);
StaticMeshActor->MarkComponentsRenderStateDirty();
~~~

## 删除 Actor
~~~
AActor::Destroy
UObject::ConditionalBeginDestroy
~~~

## 检测 Actor
~~~
check(ThisActor);
check(ThisActor->IsValidLowLevel());
~~~

## 获得 UE4 版本
GEngineVersion

## 定时器回调
~~~
FTimerHandle TimerHandle;
FTimerDelegate TimerDelegate;
TimerDelegate.BindLambda([this, HitMeshComponent] {});

GetWorld()->GetTimerManager().SetTimer(TimerHandle, TimerDelegate, 0.5, false);
~~~

## 显示或关闭组件边框线
UPrimitiveComponent::SetRenderCustomDepth

## 时间线
蓝图组件：TimeLine

## 转换屏幕位置到3D空间
1. FSceneView::DeprojectScreenToWorld
2. UGameplayStatics::DeprojectScreenToWorld

## 获得字符串宽度
~~~
const TSharedRef< FSlateFontMeasure > FontMeasure = FSlateApplication::Get().GetRenderer()->GetFontMeasureService();
FVector2D Size = FontMeasure->Measure(*String, GEngine->GetMediumFont()->GetLegacySlateFontInfo());
~~~

## 获得窗口的宽高
~~~
FSceneViewProjectionData::GetConstrainedViewRect
可以用ULocalPlayer::GetProjectionData获得FSceneViewProjectionData
可以用APlayerController::GetLocalPlayer获得ULocalPlayer
~~~

## 输出内存信息到磁盘
控制台下Memreport【UEngine::HandleMemCommand】

## 获得内存信息
FPlatformMemory::GetStats

## 捕获堆栈信息
FWindowsPlatformStackWalk::CaptureStackBackTrace

## 点关闭按钮后做特别处理
~~~
// TSharedPtr<SWindow> ActiveTopLevelWindow = GEngine->GameViewport->GetWindow();
TSharedPtr<SWindow> ActiveTopLevelWindow = FSlateApplication::Get().GetActiveTopLevelWindow();
FRequestDestroyWindowOverride RequestDestroyWindowOverride;
RequestDestroyWindowOverride.BindLambda([](const TSharedRef<SWindow>& WindowBeingClosed)
{
	UE_LOG(LogTemp, Log, TEXT("%s 執行了關閉"));
});
ActiveTopLevelWindow->SetRequestDestroyWindowOverride(RequestDestroyWindowOverride);
~~~

## 怎么在一个死循环里处理游戏循环
~~~
【FAsyncTask】
【FTaskGraphInterface::Get().WaitUntilTaskCompletes(CompleteHandle);】
【
do
	{
		CheckRenderingThreadHealth();
		if (bEmptyGameThreadTasks)
		{
			// process gamethread tasks if there are any
			FTaskGraphInterface::Get().ProcessThreadUntilIdle(ENamedThreads::GameThread);
		}
		bDone = Event->Wait(WaitTime);
	}
while (!bDone);
】
~~~

## 获得当前帧鼠标移动距离
APlayerController::GetInputMouseDelta

## 旋转增量
AActor::AddActorLocalRotation

## UMaterialInstanceDynamic 设置纹理
~~~
UMaterialInstanceDynamic* MaterialInstanceDynamic = UKismetMaterialLibrary::CreateDynamicMaterialInstance();
UTexture2D* LoadedTexture = LoadObject<UTexture2D>();
if (LoadedTexture)
	MaterialInstanceDynamic->SetTextureParameterValue();
~~~

## 获得纹理尺寸
~~~
UMaterialInstanceDynamic* MaterialInstanceDynamic = ？？？？？？;
UTexture* Texture = NULL;
if (MaterialInstanceDynamic->GetTextureParameterValue(TEXT("tBaseTexture"), Texture))
{
	if (Texture->Resource)
	{
		SizeX = Texture->Resource->GetSizeX();
		SizeY = Texture->Resource->GetSizeY();
	}
}
~~~

## 绘制自定义网格
继承这个类：UProceduralMeshComponent

## 检查UActorComponent的标签
UActorComponent::ComponentHasTag

## 判断组件材质的是否为半透明的混合模式
~~~
UMaterialInterface* MaterialInterface = Component->GetMaterial(???);
IsTranslucentBlendMode(MaterialInterface->GetBlendMode())
~~~

## 克隆一个AActor
~~~
AActor* pTemplate;
FActorSpawnParameters* params = new FActorSpawnParameters();
params->Template = pTemplate;
AActor* newActor = GetWorld()->SpawnActor(pTemplate->GetClass(), 位置, 旋转, *params);
GetWorld()->AddNetworkActor(newActor);
~~~

## 克隆一个UActorComponent组件
~~~
AActor* Actor;
UActorComponent* ActorComponent = Actor->CreateComponentFromTemplate(要克隆的组件);

ActorComponent->RegisterComponent();
ActorComponent->AddInstanceComponent(newComponent);
~~~

## 创建边框盒
~~~
这个真是方便，只要给顶点数据就可以了
FBox Box;
Box += FVector;
~~~

## Dynamic UObject Allocation
.H
```
UPROPERTY()
UMyObjectClass* MyGCProtectedObj;
```
.CPP
```
MyGCProtectedObj = NewObject<UMyObjectClass>(this);
```

> **用 UPROPERTY() 防止垃圾收集，如果不用 UPROPERTY()，防止垃圾收集，可以用：YourObjectInstance->AddToRoot();**

## 动态创建UObject（所有继承于UObject）
1. CreateDefaultSubobject 只能在构造函数里使用
2. NewObject 可以在任何地方使用【也可以用ConstructObject，4.8版本后这个就不建议用了】
3. 下面这个写法不用通过TSubclassOf<UObject>到蓝图里指定UClass instance
	> NewObject<UObject>(GetTransientPackage(), UObject::StaticClass());

## 动态创建UActorComponent
~~~
UActorComponent* NewComponent = NewObject<UActorComponent>(this, UActorComponent::StaticClass());
NewComponent->RegisterComponent();
NewComponent->AttachTo(GetRootComponent());
NewComponent->SetWorldLocationAndRotation(NewLocation, NewRotation);
~~~

## IsPendingKill() vs IsValidLowLevel()
~~~
https://answers.unrealengine.com/questions/211586/ispendingkill-vs-isvalidlowlevel.html
IsPendingKill：检测对象是否rendering current frame后销毁
IsValidLowLevel：检测对象是否有效
~~~

## UStaticMesh vs UInstancedStaticMeshComponent
~~~
https://answers.unrealengine.com/questions/10984/question-difference-between-instancedstaticmesh-an.html

InstancedStaticMeshComponents are used to draw multiple instances of the same StaticMesh in one draw call. You basically add one of those (per StaticMesh asset you need to draw) and then add instances to it along with the transform (position, rotation, scale) for each instance. So, if you have one StaticMesh that needs to be placed many times, this could be an optimization. If you just have lots of different StaticMeshes you are adding to your Blueprint, I don't think you would see any improvement.
~~~

## GetPlayerCameraManager
UGameplayStatics::GetPlayerCameraManager

## SetViewTargetWithBlend / SetViewTarget
APlayerController::SetViewTarget：第一个参数class AActor* 类型，没搞明白处理视口的流程？？？？？？

## 判断浮点数近似相等可以用
KINDA_SMALL_NUMBER

## Json操作
~~~
TJsonReaderFactory
FJsonSerializer
FJsonObject
FJsonObjectConverter::JsonObjectStringToUStruct
~~~

## 绘制常用图形函数
~~~
SceneManagement.h

绘制蚂蚁线：DrawDashedLine
~~~

## 绑定一个ACtor到另一个ACtor
AActor::AttachRootComponentToActor

## 获得ACtor下绑定的其它ACtor
AActor::GetAttachedActors

## 字符转换函数
~~~
StringConv.h

TCHAR_TO_ANSI ANSI_TO_TCHAR TCHAR_TO_UTF8 UTF8_TO_TCHAR
~~~

## C 字符串操作
~~~
TCString

封装了一些 C 字符操作的 Api
~~~

## 干净的浮点转 FString
~~~
FString::SanitizeFloat

For example - 1.234 will be "1.234" rather than "1.234000"
~~~

## 快速关闭
~~~
FPlatformMisc::RequestExit(true);
~~~

## 正常关闭
~~~
APlayerController* playerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);
if (playerController)
{
    //EQuitPreference::Quit 完整退出
    //EQuitPreference::Background 移动到后台退出
    UKismetSystemLibrary::QuitGame(GetWorld(), playerController, EQuitPreference::Quit);
}
~~~

## UObject 实现 Tick
集成自 UObject 的类，实现Tick，可以再继承 FTickableGameObject

## !HasAnyFlags(RF_ClassDefaultObject)
？？？看文档没看明白，这个可以在编辑器下进行当前类的状态监测？？？
```
bool FTickableGameObject::IsTickable() const
{
	return !HasAnyFlags(RF_ClassDefaultObject);
}
```

## 获得PlayerController
```
UGameplayStatics::GetPlayerController
```

## 检测按键是否按下
```
APlayerController::IsInputKeyDown
```

## 屏幕坐标到世界坐标
```
FSceneView::DeprojectScreenToWorld
```

## 物体绕某个点旋转（基于四元数）
```
URotatingMovementComponent::TickComponent
```

## 获得GameInstance
```
UGameplayStatics::GetGameInstance
AActor::GetGameInstance
```

## 获得FSceneViewport
```
FSceneViewport* Viewport = AActor::GetGameInstance()->UGameInstance::GetGameViewportClient()->UGameViewportClient::GetGameViewport();
```

## 获得窗口长宽比
```
FViewport::GetDesiredAspectRatio
```

## 居中显示物品
```
FEditorViewportClient::FocusViewportOnBox
```

## 获得物品的边框
```
virtual FBox AActor::GetComponentsBoundingBox
```

## 门的开关
```
TimeLine + UKismetMathLibrary::TEase
```

## 代码到蓝图

## ModuleRules (2016-10-14 ~ )

~~~
1. 直接绑定一个按键：BindKey
~~~
~~~
2. GetWorldTimerManager().SetTimer
~~~
~~~
3. Using Timers in Blueprints
https://docs.unrealengine.com/latest/INT/Gameplay/HowTo/UseTimers/Blueprints/index.html
~~~
~~~
4. 让镜头围绕人物旋转
{
ACharacter::bUseControllerRotationYaw = false;
USpringArmComponent::bUsePawnControlRotation
}
~~~
~~~
5. 镜头跟随人物旋转
{
ACharacter::bUseControllerRotationYaw = true;
}
~~~
~~~
6. 控制跳起后，如果转身，是否还能在空中移动，=0跳转后只能在空中转身，不能移动
UCharacterMovementComponent::AirControl
~~~
~~~
7. FOnTimelineFloat，BindUFunction的回调函数，声明时要加UFUNCTION()关键字，不然不会触发回调
~~~
~~~
8. 获得当前镜头跟随的生物
class APlayerCameraManager* APlayerController::PlayerCameraManager;
APawn* APlayerCameraManager::GetViewTargetPawn()
~~~
~~~
9. UFUNCTION(BlueprintImplementableEvent) 传递FString参数
void BlueprintImplementableEventFunction(const FString& String);
~~~
~~~
10. GEngine->GetFirstLocalPlayerController
~~~
~~~
11. RPC (client to server) on owning actor not working

void ABasePlayerController::ServerSpawnSoldiers_Implementation(const TArray<ESoldierTypes>& aSoldierArray, FVector aPosition, APlayerController* aOwner)
      {
          UE_LOG(LogTemp, Warning, TEXT("received soldier spawn"));
          FActorSpawnParameters tParams;
          tParams.Owner = aOwner;
          ABaseSoldier* tSoldier = (ABaseSoldier*)GetWorld()->SpawnActor(mMeleeSoldier, &aPosition, &FRotator::ZeroRotator, tParams);
          tSoldier->GetController()->SetOwner(aOwner);
      }
~~~
~~~
12. 三种动作映射方式
这两个是需要在编辑配置按键映射的
{
	1. BindAxis：这个是有数值传入的，比如前后左右移动，传入的移动增值	
	2. BindAction：这个判断按键响应状态，比如是按下、抬起、组合键。
}
这个不需要在编辑器配置按键映射
{
	3. BindKey，这个直接传入按键值 EKeys::R
} 
~~~
~~~
13. 切换观察者和玩家
void APlayerController::ChangeState(FName NewState)
~~~
~~~
14. FTimeline SwitchCameraTimeline;
~~~
~~~
15.  枚举转字符串
https://wiki.unrealengine.com/Enums_For_Both_C%2B%2B_and_BP

FString GetVictoryEnumAsString(EVictoryEnum::Type EnumValue)
{
  const UEnum* EnumPtr = FindObject<UEnum>(ANY_PACKAGE, TEXT("EVictoryEnum"), true);
  if(!EnumPtr) return FString("Invalid");
 
  return EnumPtr->GetNameByValue((int64)EnumValue); // for EnumValue == VE_Dance returns "VE_Dance"
}
~~~
~~~
16. 在服务器获得所有玩家
for (FConstPlayerControllerIterator Iterator = GetWorld()->GetPlayerControllerIterator(); Iterator; ++Iterator)
~~~
~~~
17. 解决按键冲突
FInputBinding::bConsumeInput = false
~~~
~~~
18. for (auto PawnActor : TActorRange<APawn>(GetWorld()))
~~~
~~~
19. 在c++创建的组件【CreateDefaultSubobject】，虽然在编辑器里可以看到，但是要调用【SetupAttachment】
~~~
~~~
20. 人物换装的一个实现，是多个USkeletalMeshComponent的组合，子USkeletalMeshComponent要调用SetMasterPoseComponent
~~~
~~~
21. 用NewObject创建出来的Component，要调用RegisterComponent，CreateDefaultSubobject 创建出来的Component，不需要再调用RegisterComponent
~~~
~~~
22. 设置父类的成员对象类型
1. 子类里 GENERATED_UCLASS_BODY()
2. 子类构造函数 : Super(ObjectInitializer.SetDefaultSubobjectClass<UPlatformerPlayerMovementComp>(ACharacter::CharacterMovementComponentName))
~~~
~~~
23. 偏移子组件的位置，一定要把偏移量根据父组件的旋转做一次旋转
FQuatRotationMatrix(ParentRotator.Quaternion()).TransformVector(OffsetVector);
~~~
~~~
24. 在 客户端处理模拟角色移动后 需要增加的业务逻辑
1. AActor::PostNetReceiveLocationAndRotation
这个是 FRepMovement AActor::ReplicatedMovement 被服务器改变后，客户端的同步通知回调，配合virtual void SmoothCorrection(const FVector& OldLocation, const FQuat& OldRotation, const FVector& NewLocation, const FQuat& NewRotation) PURE_VIRTUAL(INetworkPredictionInterface::SmoothCorrection,);函数，圆滑移动？
~~~
~~~
2. void UCharacterMovementComponent::SmoothClientPosition
~~~
~~~
1.	UFUNCTION(BlueprintImplementableEvent)，FString参数只能传递引用
~~~
~~~
2.	FStreamableManager::RequestAsyncLoad，异步加载
~~~
~~~
3.  	// 转化到当前actor的坐标系下
	Vector = GetActorTransform().Inverse().TransformVector(Vector);
~~~
~~~
4.	/** Flags all component's render state as dirty	 */
	void MarkComponentsRenderStateDirty();
~~~
~~~
	5. FScopedPreventAttachedComponentMove类可以限制某个组件暂时不跟随父类组件移动。
~~~
~~~
6. 	FMath::FInterpTo(CurrentSwimSpeed, MovementSpeed.SwimSpeed, DeltaTime, 1);
~~~
~~~
7.	/** 重载这个，可以判断是否进入一个别的物理体 */
	APhysicsVolume::IsOverlapInVolume
~~~
~~~
8.	/** 重点 */
	移动圆滑处理：服务器一步到位，客户端做插值
~~~
~~~
9.	Cannot create Blueprint class based
	UCLASS(Blueprintable) 
~~~
~~~
10.	UAnimInstance::GetStateMachineIndexAndDescription 得到状态机
	UAnimInstance::GetInstanceStateWeight 获得状态机权重，检测一个状态是否切换结束
~~~
~~~
	/** 检测和那些组件产生了碰撞 */
11.	UPrimitiveComponent::GetOverlapInfos()
	获得和UPrimitiveComponent产生Overlap的所有FHitResult
~~~
~~~
12.	UPrimitiveComponent::ComponentOverlapMulti
	同时检测多个碰撞体的碰撞
~~~
~~~
13. 	APawn::FaceRotation
	设置生物的旋转
~~~
~~~
14.	APlayerController::InputYawScale/InputPitchScale/InputRollScale
	设置视口的旋转速度
~~~
~~~
	/** 关键函数 */
15.	APlayerController::UpdateRotation
	串联起了相机管理、玩家控制、生物的旋转操作
~~~
~~~
16.	瞄准时的中间正常，四周虚化
	APlayerCameraManager::UpdateViewTarget(FTViewTarget& OutVT, float DeltaTime)
	FTViewTarget.POV.PostProcessSettings，通过这里传递后处理相关的材质
~~~
~~~
17.	换观察玩家视角
	APlayerController::SetViewTarget
	ServerViewSelf、ServerViewNextPlayer：这个会服务器和客户端都执行SetViewTarget
~~~
~~~
18.	观察和正常状态的切换
	APlayerController::ChangeState
~~~
~~~
19.	当前相机是第一人陈/第三人称/自由模式
	APlayerCameraManager::CameraStyle
~~~
~~~
20.	如果GetMovementComponent()没有设置单独的PhysicsVolume()，那么这个设置是全局的TerminalVelocity一定慎重【GetMovementComponent()->GetPhysicsVolume()->TerminalVelocity】
~~~
~~~
1.	Replicated 的属性，只有值改变了才会同步到客户端【有强制同步的么？】
~~~
~~~
2.	获得和PrimitiveComponent产生Overlap的所有Info，这个是每帧都有处理的
	UPrimitiveComponent::GetOverlapInfos()
~~~
~~~
3.	获得当前生物踩的PrimitiveComponent，这个是适时更新的
	UCharacterMovementComponent::CurrentFloor
~~~
~~~
4.	获得角色和当前地面夹角
	const float FloorDotVelocity = FVector::DotProduct(Movement->CurrentFloor.HitResult.ImpactNormal, Movement->Velocity.GetSafeNormal());
	FMath::RadiansToDegrees(FMath::Acos(FloorDotVelocity))
~~~
~~~
5.	获得能走斜坡角度
	const UPrimitiveComponent* HitComponent = Hit.Component.Get();
	if (HitComponent)
	{
		const FWalkableSlopeOverride& SlopeOverride = HitComponent->GetWalkableSlopeOverride();
		TestWalkableZ = SlopeOverride.ModifyWalkableFloorZ(TestWalkableZ);
	}

	UCharacterMovementComponent::CurrentFloor
~~~
~~~
6.	/** 这个有演示怎么撤销移动 */
	bool UCharacterMovementComponent::StepUp(const FVector& GravDir, const FVector& Delta, const FHitResult &InHit, FStepDownResult* OutStepDownResult)
~~~
~~~
7.	/** 这个有演示怎么提前模拟计算移动 */
	UProjectileMovementComponent::TickComponent
~~~
~~~
8.	/** 移动撤销？ */
	RevertMove
~~~
~~~
9.	/** 旋转? */
	ComputeOrientToMovementRotation
~~~
~~~
10.	/*这个会阻止附加的某个组件不移动*/
	FScopedPreventAttachedComponentMove
~~~
~~~
11.	/* 获得预测数据 */
	GetPredictionData_Client
~~~
~~~
12.	判断是否能移动
	UCharacterMovementComponent::IsWalkable
~~~
~~~
13.	根据方向构造一个面
	UMovementComponent::ConstrainDirectionToPlane
~~~
~~~
1.	获得对象缺省的字段信息
	GetDefault<AObject>(Object->GetClass());
	Object->GetClass()->GetDefaultObject()
~~~
~~~
2.	获得角色立足的物体信息
	ACharacter::BasedMovement
	UCharacterMovementComponent::GetMovementBase()
	FFindFloorResult UCharacterMovementComponent::CurrentFloor
~~~
~~~
3.	撤销当前移动
	UCharacterMovementComponent::RevertMove
~~~
~~~
4.	SCOPE_CYCLE_COUNTER
	有
~~~
~~~
5.	USceneComponent::SetRelativeLocationAndRotation
	这个有计算目标移动和现有位置的增量
~~~
~~~
6.	AController::SetControlRotation
	这个有旋转变化会执行
~~~
~~~
7.	AInstancedFoliageActor::FoliageTrace
	演示怎么碰撞体扫描
~~~
~~~
MarkRenderStateDirty
~~~
~~~
{
	速率根据加速度计算，人物运动分为两个部分：朝向，前进方向

	Control 的旋转根据 输入设置计算
	加速度，客户端传递给服务器，根据 输入值 和 朝向【可以是角色、Control或其它任何旋转】 计算

	1. 朝向：根据 Control 的旋转设置，朝向可以设置是否跟随 Control，具体可以看 	APawn::FaceRotation、APlayerController::UpdateRotation

	2. 前进方向【速率】：根据 加速度 计算

	按Alt在水里游泳的问题是：
	旋转朝向正常，角色不用 Control 的旋转
	加速度不正常，用的 Control 的旋转

	按Alt在跑动的问题是：
	APawn::bUseControllerRotationYaw 不同步，导致 APlayerController::UpdateRotation->APawn::FaceRotation 里处理角色朝向，客户端和服务器不同
}
~~~
~~~
鬼影是由于taa造成的，实现方法是修改控制台里taa和前后帧的影响权重，是得鬼影现象弱化，但是这样做会让画面变的锐利感很强。
~~~
~~~
1.	服务器调用客户端设置视口目标
	APlayerController::ClientSetViewTarget
~~~
~~~
2.	客户端设置视口目标
	APlayerController::SetViewTarget
~~~
~~~
1.	动态调整眼高【比如蹲下和站立】，可以继承下面函数，做 BaseEyeHeight 插值
	RecalculateBaseEyeHeight
~~~
~~~
2.	USceneComponent::GetPhysicsVolume() 这个可以判断当前所处的PhysicsVolume，比如是否在水体
~~~
~~~
2. 网络状态更新，在一帧内，可能不同逻辑会对一个地方重复处理，在不能确保所有执行顺序逻辑的情况下，为了确保一个状态一定会更新，可以用settime，延迟到下一帧执行
~~~
~~~
碰撞通道
1. LineTraceSingleByChannel 只会对 Trace Channel 为 Block 的 有回应，对OverLay的L略过
~~~
~~~
功能点
1.	增加命令行命令
	DECLARE_CYCLE_STAT

1.	回复值到初始值
	TGuardValue
	TScopeCounter

1.	这个演示怎么处理掉输入，以及怎么向服务器告诉移动信息
	UCharacterMovementComponent::TickComponent

2.	这个执行一次后就会让移动收入清零
	Internal_ConsumeMovementInputVector
	GetPendingMovementInputVector
	UPawnMovementComponent::ConsumeInputVector

	UPawnMovementComponent::GetPendingInputVector()
3.	输入的产生、消费、处理
	AddMovementInput(Direction, ScaleValue);
	ConsumeInputVector();
	UCharacterMovementComponent::TickComponent
4.	PhysWalking 前需要执行的两个函数
	Acceleration = ScaleInputAcceleration(ConstrainInputAcceleration(InputVector));
	AnalogInputModifier = ComputeAnalogInputModifier();
~~~
~~~
1. 穿透调整
UMovementComponent::GetPenetrationAdjustment
2.	演示怎么根据穿插回调
void UCableComponent::PerformCableCollision()
3. 穿插调整
UMovementComponent::GetPenetrationAdjustment
~~~
~~~
DrawDebugSweptSphere
DrawDebugCapsuleTraceSingle
~~~
~~~
有移动撤销
UCharacterMovementComponent::StepUp
~~~
~~~
{
	移动遇到碰撞体处理
	UCharacterMovementComponent::HandleImpact

	调用

	移动遇到碰撞体处理
	ACharacter::MoveBlockedBy
}
~~~
~~~
/** 移动撤销？ */
RevertMove
~~~
~~~
/** 这个有演示怎么撤销移动 */
StepUp
~~~
~~~
/** 移动的可视化调试信息 */
VisualizeMovement
~~~
~~~
/* 这个会阻止附加的某个组件不移动 */
FScopedPreventAttachedComponentMove
~~~
~~~
float GetInstanceStateWeight(int32 MachineIndex, int32 StateIndex);
GetStateMachineIndexAndDescription
~~~
~~~
ControlRotation与ActorRotation
APawn::GetActorEyesViewPoint
APlayerController::UpdateRotation
APawn::FaceRotation
~~~
~~~
DrawDebugDirectionalArrow(GetWorld(), DesiredLoc, DesiredLoc + ToOrigin * 0.5f, 7.5f, bClampedDist ? FColor::Red : FColor::Green);
~~~
~~~

【地形学习】

材质编辑器：主要是把颜色作为基本运算单元，做各种计算【+-*/%】，红色：#FF0000 绿色：#00FF00，那么这两个相加就是：#FFFF00。图片由各种颜色组成，都可以对应到10101010，除了颜色本身外，颜色一般标识为R，G，B，额外参数是Alpha值，控制颜色混合时的权重

地形编辑器：主要是把顶点作为基本运算单元，做各种计算【+-*/%】，比如一个山高1000，另一个山高1000，那么这两个山高相加就是2000，顶点一般在三维空间表示为X，Y，Z，额外参数是W ？？？

颜色和顶点在计算机里都是浮点数的集合，所以可以很方便进行各种运算，和各种插值操作，比如一个山高1000，另一个山高2000，两个山之间做线性插值，那么在两个山之间的中点高为1500，比如一个颜色是红色，另一个绿色，那么在

根据以上，所以顶点和颜色可以互相转换，顶点可以转换为颜色，颜色可以转换为顶点，比如

Generator
【
	Radial Grad: 产生一个圆锥山体
	Voronoi: 坑坑洼洼的地形
	Constant：和别的山做运算，让别的山保持山形状的情况下，调节山高
	Gradient：改变山体的朝向，让山体变的圆滑和降低高度，可以做到地形的切片效果
	Color Generator：根据山体高度生成颜色
	Layout Generator：自己绘制山体的走势
	Perlin Noise：数字化造山
	Advanced Perlin：数字化造山，增强版
】

Combiner
【
	Combiner：组合不同的地形，有几种组合方法，合理的利用，可以中和尖的，拉高低的，降低低的
】

Filter
【
	Clamp：改变山的高度相关，不光是整体山高，比如可以让山顶扩大，山变的陡峭，增加山的垂直高度，降低地平面
	Simple Transofrms：改变山的峡谷、高原、山体等
	Terrace：梯田？？？
	Curves：曲线，这个好玩，无意义？？？
	Simple Displacement：旋转地形，让地形偏移
	Ramp：把地形转换为波纹
	Height Splitter：把地形转换为环形
	Add Noise：增加地形的坑坑洼洼
	Flipper：左右或上下翻转地形
	Equalizer：降低山的尖度？？？
	Blue：让山的尖度变圆润？？？
	Expander：使山体高低不平的逐渐填平
	Inverter：让高的变低，低的变高
	Bias/Gain: 让高的更高，低的更低
】

https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/HowTo/CreatingLayeredMaterials/index.html
WorldAlignedBlend
WorldAlignedNormal
WorldAlignedTexture
SlopeMask
MatlayerBlend_Simple
MatlayerBlend_Standard
ComponentMask
MakeMaterialAttributes
MatLayerBlend_StandardWithDisplacement
【
WorldAlignedTexture：全局一致纹理【函数用于在全局空间中的对象表面上平铺纹理，此平铺与该对象的大小或旋转无关。此函数允许您指定投射纹理的方向，并按全局单位（而非纹理大小的百分比）进行比例调整】
因为此函数在全局空间内平铺纹理，所以需要注意，任何以此方式处理纹理的动画对象都会发生纹理“漂浮”，即纹理保持原位置不动，而对象在其下方滑动
】
【
HeightLerp：高度插值【函数允许您根据高度贴图和过渡阶段值，在 2 个纹理之间执行线性插值。这允许您沿着发生插值的高度贴图来调整值】
】
PixelDepth：像素深度【表达式输出当前所渲染像素的深度，即从摄像机开始计算的距离】
SceneDepth：场景深度【类似于 PixelDepth（像素深度），PixelDepth（像素深度）只能在当前所绘制像素处进行深度取样，而 SceneDepth（场景深度）可以在 任何位置 进行深度取样】
Divide
LinearInterpolate
FuzzyShading1
Clamp
Landscape Layer Sample
Bump Offset: 设置凹凸贴图偏移【https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/HowTo/BumpOffset/index.html】
Panner：产生 UV 坐标动画【https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/HowTo/AnimatingUVCoords/index.html】
后期处理体积【Post Process Volume】
Detail Texturing：细节纹理化【https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/HowTo/DetailTexturing/index.html】

https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/ExpressionReference/Vector/index.html#cameravectorws
https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/HowTo/Making_Functions/index.html
{
	ActorPositionWS：Actor 全局空间位置【输出 Vector3 (RGB) 数据，该数据代表使用此材质的对象在全局空间中的位置】
	CameraWorldPosition：摄像机全局空间位置【表达式输出三通道矢量值，该值代表摄像机在全局空间中的位置】
	CameraVectorWS：摄像机全局空间矢量【表达式输出一个三通道矢量值，该值代表摄像机相对于表面的方向，即从像素到摄像机的方向】
}

https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/HowTo/Fresnel/index.html

坐标表达式
https://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/ExpressionReference/Coordinates/index.html

LandscapeLayerWeight：地形图层权重节点【表现允许材质网络进行混合。混合的基础是从材质应用的地形上所获取的相关图层权重】
LandscapeLayerSample：这个会产生绘制层
LandscapeLayerBlend：【LB Height Blend，这个选项能产生沙子层里的沙子落在岩石层里的岩石缝隙里？？？？？？】
~~~
~~~
// 这个可以把不在视口里的位置映射到视口UI坐标么？
UWidgetLayoutLibrary::ProjectWorldLocationToWidgetPosition
USlateBlueprintLibrary::ScreenToViewport

// 从结构上看，所有的数据（data）最终都可以分解成三种类型
{
	第一种类型是标量（scalar），也就是一个单独的字符串（string）或数字（numbers），比如"北京"这个单独的词。

	第二种类型是序列（sequence），也就是若干个相关的数据按照一定顺序并列在一起，又叫做数组（array）或列表（List），比如"北京，上海"。

	第三种类型是映射（mapping），也就是一个名/值对（Name/value），即数据有一个名称，还有一个与之相对应的值，这又称作散列（hash）或字典（dictionary），比如"首都：北京"。
}

// 检测是否看到其它 Actor
AController::LineOfSightTo

// 重载 AActor::IsBasedOnActor 碰撞检测时是否跳过
UPrimitiveComponent::MoveComponentImpl -> ShouldIgnoreHitResult -> AActor::IsBasedOnActor -> AActor::IsAttachedTo

// UPROPERTY 子 Category
UPROPERTY(EditAnywhere, Category = "A|B")

// 求夹角
CalculateAngleDifferenceDot(const FVector& VectorA, const FVector& VectorB)
{
	VectorA.CosineAngle2D(VectorB)
}

// UPROPERTY 鼠标放上的提示
/** Text Text Text Text Text Text Text Text*/
UPROPERTY(EditAnywhere)

// UE4 中返回T*的函数，基本上UE4会做转换
template< class T >
T* GetXxxxx() const
{
	return Cast<T>(Xxxxx);
}

// UBTAuxiliaryNode 中有几个变量控制对应函数是否执行，如果函数没执行，看下开关是否开了
	bNotifyBecomeRelevant = false;
	bNotifyCeaseRelevant = false;
	bNotifyTick = false;
	bTickIntervals = false;

行为树：
1. 行为树只刷新激活的分支，跳出激活的分支要执行特殊的逻辑(下面的1：属于执行结束。2：属于终止执行)，
   否则即便分支的进入条件改变，分支也会继续执行，分支内的变化不会向上层返回执行结果
【
	1. 调用Finish Execute（在任务节点的Event Receive Execute AI调用）。
	2. 设置分支可以终止执行（行为树节点的Decorator部分<如果有>，Decorator->Flow Control->Observer aborts = None/Self/Lower Priority/Both）
】
2. BTDecorator、BTService：只有执行相关的节点才会被调用
3. 执行到一个节点，先执行BTDecorator，如果为TRUE，执行后续逻辑
4. BTService在当前节点激活后，会按设置的时间间隔不断重复执行

BTTask:执行具体任务
Event Receive Execute AI: 当前分支激活，第一次会调用。
Event Receive Tick AI:当前分支激活，会重复调用。

BTDecorator:条件语句，决定节点是否能被执行
Perform Condition Check AI:执行到BTDecorator，会先执行这个函数，如果为True，执行后续条件
Event Receive Execution Start AI: 当前分支激活，第一次会调用

BTService:只要其分支节点被执行，它们便将按所定义的频率执行
Event Receive Search Start AI:执行到BTService，会先执行这个函数，查找能执行的分支
Event Receive Activation AI:找到能执行分支，这个会调用一次
Event Receive Tick AI:在当前节点激活，重复执行


// APlayerController::ClientGotoState
APlayerController::ClientGotoState 客户端调用 APlayerController::ChangeState

// 获得当前 GameMode
GetWorld()->GetAuthGameMode()

// 产生 PlayerState 的是 AController::InitPlayerState
{
	AI的 PlayerState 需要开关
	开关：AAIController::bWantsPlayerState

	AAIController::PostInitializeComponents: 判断 bWantsPlayerState 是否为 true 执行 InitPlayerState
	【产生 Controller 也可以用 AGameModeBase::SpawnPlayerControlle】
	【
		UWorld::SpawnActor(AAIController.Class)
		AActor::PostSpawnInitialize
		AActor::FinishSpawning
		AActor::PostActorConstruction
		AAIController::PostInitializeComponents
		AController::InitPlayerState
	】
	APlayerController::PostInitializeComponents：执行 InitPlayerState
	【AGameModeBase::Login 会执行 AGameModeBase::SpawnPlayerController 和 AGameModeBase::InitNewPlayer】
	【
		AGameModeBase::SpawnPlayerControlle
		AGameModeBase::SpawnPlayerControllerCommon【也调用了 UWorld::SpawnActor，但是 AActor::FinishSpawning 没在这个函数执行里调用到，
		因为AGameModeBase::SpawnPlayerControllerCommon调用 UWorld::SpawnActor 的函数参数 FActorSpawnParameters 的bDeferConstruction = true,
		所以执行到 AActor::PostSpawnInitialize 就没调用 AActor::FinishSpawning】
		UGameplayStatics::FinishSpawningActor【AGameModeBase::SpawnPlayerControllerCommon，先调用 UWorld::SpawnActor，再调用这个函数】
		AActor::FinishSpawning
		AActor::PostActorConstruction
		APlayerController::PostInitializeComponents
		AController::InitPlayerState
	】

	// AActor::PostInitializeComponents
	这个函数 AController、APlayerController、AAIController 都有重载
}

// AI 用到
{
	aimoff:瞄准偏移，根据这个调整瞄准瞄准玩家
	sharefromxxx:避免一个指针产生两个不同的共享指针
}

// 中文注释会影响到 UBT ？？？
中文注释会影响到 UBT ？？？导致代码逻辑错误，这个比较坑

// 在头文件中对变量赋值也会影响到 UBT ？？？
在头文件中对变量赋值也会影响到 UBT ？？？导致代码逻辑错误，这个比较坑

// 当前镜头跟随的 Actor 可以是任意的
APlayerController::SetViewTarget
APlayerCameraManager::SetViewTarget

// 观察者相关的
APlayerController::SetPlayer
APlayerController::ChangeState // 切换观察者和非观察者
APlayerController::BeginSpectatingState
APlayerController::BeginPlayingState();

ServerViewNextPlayer
ServerViewPrevPlayer

AssignViewTarget
SetSpectatorPawn
BeginSpectatingState

ClientSetViewTarget_Implementation
ServerVerifyViewTarget
ServerSetSpectatorLocation

// 蓝图里设置结构体的值
1. Set Members

// 朝向转换为旋转
AActor::GetActorForwardVector().Rotation()

// 设置视口目标的回调
AActor::BecomeViewTarget
AActor::EndViewTarget

// 这个是做什么的 ？？？怎么用？？？
AActor::ForceNetRelevant

//
APlayerController::ForceSingleNetUpdateFor

这个是做什么的：
1. play slot animation
2. Slot 作用
3. PlaySlotAnimation

ResolvePenetration
MoveAlongFloor

// 在服务器获得所有玩家
for (FConstPlayerControllerIterator Iterator = GetWorld()->GetPlayerControllerIterator(); Iterator; ++Iterator)

// NavMesh Tile 的划分：
{
	基于中心点
	1: 往左 减少，往右 增加
	2: 往上 增加，往下 减少

	最大值在 右上
	最小值在 左下

	如果以角色为中心扫描周围单元格：
	{
		从角色所在单元格起，逐圈扫描【每圈 从左到右（col）、从下到上(row)】

		扫描规则：
		同 最小行 和 最大行 相同的行，所有列全扫描
		同 最小列 和 最大列 相同的列，所有行全扫描
	}
}

// 根据当前的位置，获得所在单元格：
ARecastNavMesh::GetNavMeshTileXY

// 把两个值合成一个KEY，可以扩展到把N个值合成一个KEY：
在 UE4 源码搜索：computeTileHash

// 在导航系统里，选择球体里随机可到达位置：
UNavigationSystemV1::K2_GetRandomReachablePointInRadius

// 设置黑板字段类型时的 可选择类型过滤：
FBlackboardKeySelector.AllowedTypes.Empty();
FBlackboardKeySelector.AddVectorFilter(this, GET_MEMBER_NAME_CHECKED(UBTTask_Explore, BlackboardKey));

// 机器人是否可以看到某个AActor：
AAIController::LineOfSightTo

// 绘制调试信息
AActor::DisplayDebug：

// 可视化LOG记录
AAIController::GrabDebugSnapshot：

// 格式化字符串
FString::Printf(TEXT("Name: %s"), Name)

// 获得随机值的类
FMath
FRandomStream

// 获得椎体里一个随机位置【可以参看UE4 射击例子里的使用】
FMath::VRandCone
FRandomStream::VRandCone

// 在任意位置增加想要执行的命令行命令
static FAutoConsoleCommand CCmdRenderDocCaptureFrame = FAutoConsoleCommand(
		TEXT("renderdoc.CaptureFrame"),
		TEXT("Captures the rendering commands of the next frame and launches RenderDoc"),
		FConsoleCommandDelegate::CreateRaw(this, &FRenderDocPluginModule::CaptureFrame));

// AnimGraph 下的 Montage Slot【在AnimGraph编辑区点右键弹出】 就是用来处理不同的 Montage【根据Slot Name区分】 在什么时机下处理

// 这样标记的函数会出现在蓝图的 EventGraph，和在蓝图自定义的 Event 图标不同，鼠标放上会提示那个类声明的
// 在蓝图UI，EventGraph显示的都是蓝图里实现的，没实现的不会显示，在C++定义的蓝图实现，在蓝图工作区点右键，在弹出的窗口里可以找到
UFUNCTION(BlueprintImplementableEvent, Category = Default)

// 执行控制台命令
GetWorld()->Exec(GetWorld(), *Final);

// 玩家发射子弹，子弹对别的玩家产生伤害，别的玩家可以根据子弹的Instigator找到发射子弹的玩家
AActor::Instigator

// 随机数处理，可以产生一个椎体的随机范围
FRandomStream RandomStream(FMath::Rand)

// A set of parameters to describe how to transition between view targets
FViewTargetTransitionParams

//
APawn::GetBaseAimRotation

//
APlayerCameraManager::ViewPitchMin
APlayerCameraManager::ViewPitchMax

//
蓝图函数：RotationFromXVector: 可以把前进的速率，转换成旋转

//
UWheeledVehicleMovementComponent::HandbrakeInput 会影响到
UWheeledVehicleMovementComponent::GetEngineRotationSpeed

// 实际碰撞的点
FHitResult::ImpactPoint
// 进行碰撞检测的图形位置
FHitResult::Location

// 根据角色旋转构造四元数
FQuat Rot = FQuat::MakeFromEuler(FVector(0, 90, UpdatedComponent->GetComponentRotation().Yaw));

// 计算两点之间的角度
FRotator Rotator = FRotationMatrix::MakeFromX(BackPos - FrontPos).Rotator();
Rotator.Normalize();
Rotator.Pitch;

//
根据当前位置和移动方向构造一个面
FPlane(GetActorLocation(), Character->GetActorForwardVector().GetSafeNormal()),

//
AActor::GetComponentByClass
AActor::FindComponentByClass
AActor::GetComponentsByTag

// SweepSingleByChannel\SweepMultiByChannel
只生成最接近的阻塞结果，之后不会进行任何测试

// 从开始位置扫描到结束位置
GetWorld()->ComponentSweepMulti

// 斜坡速率
FVector RampVector = ComputeGroundMovementDelta(Delta, CurrentFloor.HitResult, CurrentFloor.bLineTrace);

float Length = AnimInstance->Montage_GetBlendTime(StandToProneAnim);
// float Length = AnimInstance->GetInstanceTransitionCrossfadeDuration(MachineIndex, StateIndex);

// 子弹类和线粗细差不多的可以用
GetWorld()->LineTraceSingleByChannel

// 比线粗的要用【否则会出现检测线从物体旁穿过，其它部分已经交叉】：
GetWorld()->SweepSingleByChannel

// 逻辑问题，基本上分层能解决

// 重叠检测回调的 C++ 写法
UPrimitiveComponent::OnComponentBeginOverlap.AddDynamic(this, &XXX::OnBeginOverlap);

// 缺省相机距离
APlayerCameraManager::FreeCamDistance

// 判断是否同一个类
TSubclassOf<AArchitecture> AArchitectureFilter = AArchitecture::StaticClass();
if (OtherActor->IsA(AArchitectureFilter))

// 根据当前帧时间 和旋转频率【UCharacterMovementComponent::RotationRate】 计算当前帧会旋转的频率
UCharacterMovementComponent::GetDeltaRotation

// 一个Pawn 控制另一个 Pawn
牵涉到可视化裁剪，有时需要把客户端的相机信息更新到服务器
APlayerCameraManager::bShouldSendClientSideCameraUpdate

A 控制 B，一起移动，比如乘车[有比这更好的方式，只是记录一个实现方式]
A/B->AttachToComponent A/B
B->SetOwner(A);
B->Controller = A->GetController();

B->SetReplicates(true);
B->SetAutonomousProxy(true);
B->SetReplicateMovement(true);

A->SetReplicateMovement(false);
A->GetCharacterMovement()->SetMovementMode(EMovementMode::MOVE_None);
// ??????
{
	A->PlayerController->ClientSetViewTarget(B);
	A->PlayerController->SetViewTarget(A);
}

// 强制网络更新
AActor::ForceNetUpdate

//
这个 USceneComponent::bAbsoluteRotation 
会影响到 【所以一个SceneComponent AttachTo 另一个 SceneComponent 可以把这个设置为fasle】
AttachToComponent
UpdateChildTransforms
SetWorldRotation
SetWorldTransform
SetWorldLocationAndRotationNoPhysics
InternalSetWorldLocationAndRotation

// Clamps an angle to the range of [0, 360)
FRotator::ClampAxis

// 旋转考虑符号取值和角度范围

// 
UpdateCamera 只在服务器执行 ？？？
DoUpdateCamera 只在客户端执行 ？？？

~~~
~~~
UCharacterMovementComponent::CurrentFloor

UProjectileMovementComponent::HasStoppedSimulation

GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);
GetCapsuleComponent()->SetCollisionResponseToAllChannels(ECR_Ignore);

// FTimeline 不是 组件，UTimelineComponent 才是

// 时间线C++里使用
1. 在蓝图里编辑一个曲线
UPROPERTY(EditAnywhere)
UCurveFloat* CurveFloat;

2. 增加回调函数，注意：要加 UFUNCTION 不然不会回调
UFUNCTION()
void TimelineCallBack()

3. 设置回调函数
FOnTimelineFloat OnTimelineFloat;
OnTimelineFloat.BindUFunction(this, "TimelineCallBack");

4. 调用1，2
FTimeline Timeline;
Timeline.AddInterpFloat(CurveFloat, OnTimelineFloat);

5. 播放
Timeline.PlayFromStart

6. 在使用 Timeline 的 Actor / Component 的 Tick 更新 Timeline
if(Timeline.IsPlaying())
	Timeline.TickTimeline

7. 停止时回调
Timeline.SetTimelineFinishedFunc

8. 注意事项
如果不设置 Timeline.AddInterpFloat 而直接设置 Timeline.SetTimelineFinishedFunc，那么 FTimeline::GetTimelineLength 会是 0

// 立即停止 / 关闭，这个和 Restart 配合使用
APawn::TurnOff

//
SetActorEnableCollision
StopMovementImmediately

// Move the capsule, but not the mesh.
// Note: we don't change rotation, we lerp towards it in SmoothClientPosition.
const FScopedPreventAttachedComponentMove PreventMeshMove(CharacterOwner->GetMesh());
UpdatedComponent->SetWorldLocation(NewLocation, false, nullptr, GetTeleportType());

// 网络复制相关设置，如果一个
bReplicates
IsNetRelevantFor
bAlwaysRelevant
bReplicateMovement
NetUpdateFrequency
MinNetUpdateFrequency
NetCullDistanceSquared

// 给曲线增加一个中点
Spline->ClearSplinePoints();

Spline->AddSplineLocalPoint(StartLocation);
Spline->AddSplineLocalPoint(TargetLocation);

float MidPoint = Spline->GetSplineLength() / 2.f;
FVector MidLocation = Spline->GetLocationAtDistanceAlongSpline(MidPoint, ESplineCoordinateSpace::Local);
Spline->AddSplinePointAtIndex(MidLocation, 1, ESplineCoordinateSpace::Local);

// 获得角色站立的 Actor
Character->GetCharacterMovement()->CurrentFloor.HitResult.Actor

// 断尾
https://www.bilibili.com/video/av36477688?from=search&seid=2786145945818443984

// 使用引擎的全局變量
extern ENGINE_API float GAverageFPS;
return GAverageFPS;

// 增加新的 碰撞 Object Channels 并在代码使用
1. 在编辑器里的：Engine - Collision 里增加新的 Object Channels

2. 在 C++ 里
UPROPERTY(EditDefaultsOnly, BlueprintReadWrite)
TEnumAsByte<EObjectTypeQuery> ObjectTypeQuery;

3. 在编辑器里，把新增加的 Object Channels 设置给 ObjectTypeQuery

4. 在 C++ 里使用
FCollisionObjectQueryParams ObjectParams;
ObjectParams.AddObjectTypesToQuery(UEngineTypes::ConvertToCollisionChannel(ObjectType));
if (!ObjectParams.IsValid())
	return nullptr;

// 多个对象的重叠检测
GetWorld()->OverlapMultiByObjectType

// 生成碰撞图形
FCollisionShape::MakeSphere
FCollisionShape::MakeBox

// 碰撞检测动态设置
UPrimitiveComponent::SetCollisionEnabled
UPrimitiveComponent::SetCollisionResponseToAllChannels
UPrimitiveComponent::SetCollisionResponseToChannel

// 获得 UPrimitiveComponent 运动角速度
UPrimitiveComponent::GetPhysicsAngularVelocityInDegrees

// 角速度
在旋转后，GetPhysicsAngularVelocityInDegrees 获得的值不方便使用，可以用归位到初始旋转
UPrimitiveComponent::GetComponentRotation().GetInverse().RotateVector(UPrimitiveComponent::GetPhysicsAngularVelocityInDegrees)

// 动态材质
1. 创建 UPrimitiveComponent::CreateAndSetMaterialInstanceDynamic
2. 设置 UMaterialInstanceDynamic::SetVectorParameterValue

//
Rotation Follows Velocity

// LOD
LOD 设置不同距离显示不同的Mesh，除了用作优化外，还能用作效果优化，比如一个光带，近处看一条线，远处看一个面。

// 针对组件的移动【方便测试移动】


// 对于缺省类型的

// 怎么绘制简单线框图
一：SceneProxy
1. 继承 FPrimitiveSceneProxy 生成一个子类 PrimitiveSceneProxyChild
2. 实现抽象函数 GetTypeHash、GetMemoryFootprint
3. 实现虚函数 GetDynamicMeshElements、GetViewRelevance

二：MeshComponent
1. 继承 UMeshComponent 生成一个子类 MeshComponentChild
2. MeshComponentChild 实现 CreateSceneProxy 虚函数，new 一个 PrimitiveSceneProxyChild

// 怎么绘制模型

// 高速运动下的拖影效果？？？
bHasMotionBlurVelocityMeshes
~~~
~~~
// 观察者调试
编辑器独立游戏服务器模式下，开两个玩家，选择其中一个玩家窗口，输入：
open ServerIP:ServerPort?SpectatorOnly=1

// 观察者
APlayerController::SetCameraMode // 服务器设置相机模式
APlayerController::ServerViewSelf
APlayerController::ServerViewNextPlayer
APlayerController::SetViewTarget
AController::IsInState

// UUserWidget 的子类属性，是级联的，在蓝图里子组件根据父组件，属性是变化的
比如 UUserWidget 没有 SetSize 函数
UVerticalBox 的 UVerticalBoxSlot 有 SetSize 函数

如果一个 UUserWidget 增加到 UUserWidget 在蓝图菜单里就看不到 SetSize
如果一个 UUserWidget 增加到 UVerticalBox 在蓝图菜单里就能看到 SetSize

// 创建UI，增加到视口
CreateWidget(GetWorld(), WidgetClass)
AddToViewport

// 数转换到FText
FText::AsNumber【数 转 FText】
FText::AsCultureInvariant【FString 转 FText】

// 根据秒获得时间戳
UKismetMathLibrary::FromSeconds

// 时间戳转换为文字
UKismetTextLibrary::AsTimespan_Timespan

// 
APawn::IsLocallyControlled
AController::IsLocalController

//
构造函数 改变父类的一些行为
SetDefaultSubobjectClass
DoNotCreateDefaultSubobject

// 能掰弯软鞭制作
1. 继承 UCableComponent
2. 去掉 UCableComponent 自绘制部分【CreateSceneProxy】
3. 用 USplineComponent 和 USplineMeshComponent 把 UCableComponent 的 Particles 串联起来
4. 掰弯部分主要通过 USplineMeshComponent::SetStartAndEnd 的切线参数
5. 如果掰弯效果不理想，可以尝试修改 USplineComponent::SetSplinePointType 的ESplinePointType
6. 像绳鞭，握把部分是不可弯曲的，可以设置 UCableComponent 的 End Location，然后在 USplineMeshComponent 增加点，连接到 End Component 的位置

// 获取类的私有成员
最安全的就是模板函数方式，可以看 深入学习 UE4 群的分享

// 获得角色脚下立足的组件
FFindFloorResult::FFindFloorResult

~~~
